Parfait. Ignorer la logique de validation et de mise Ã  jour de l'Ã©tat (Redis/DB) est la meilleure approche pour le moment. Nous allons nous concentrer uniquement sur la **diffusion immÃ©diate** des coordonnÃ©es de la souris d'un joueur vers l'Ã©cran de l'adversaire via le WebSocket.

Ceci est la logique de **"prÃ©sence"** ou **"aperÃ§u en temps rÃ©el"** pour le surlignage.

-----

## ğŸ› ï¸ 1. Mise Ã  Jour du Serveur WebSocket (`websocket.py`)

Nous allons ajouter une condition pour intercepter les messages de type `"selection_update"` et les diffuser sans appeler le moteur de jeu.

### Code dans `/backend/app/api/websocket.py`

Modifiez la boucle `while True` dans votre fonction `websocket_endpoint` :

```python
# /backend/app/api/websocket.py (dans websocket_endpoint)

# ... (AprÃ¨s l'Ã©tape 2. Acceptation et Enregistrement de la Connexion) ...

try:
    while True:
        data = await websocket.receive_json()
        
        # ğŸ¯ NOUVELLE LOGIQUE : Diffusion immÃ©diate pour l'aperÃ§u
        if data.get("type") == "selection_update":
            
            # Message de diffusion incluant l'expÃ©diteur et les coordonnÃ©es
            message = {
                "type": "remote_selection", 
                "sender_id": player_identifier,
                "start_index": data.get("start_index"),
                "end_index": data.get("end_index")
            }
            
            # Diffusion Ã  tous les joueurs de la partie
            await broadcast_message(game_id, message)
            
        elif data.get("type") == "validate_word":
            # âš ï¸ Ignorer la validation du moteur de jeu pour l'instant
            print(f"ACTION SKIPPÃ‰E : Validation du mot '{data.get('word')}'")
            continue 

        # ... (Reste des messages ou gestion des erreurs) ...

except WebSocketDisconnect:
    # ... (Logique de dÃ©connexion) ...
```

-----

## 2\. âš›ï¸ Logique Frontend (React)

CÃ´tÃ© React, vous devez :

1.  Stocker l'Ã©tat de la sÃ©lection de l'adversaire.
2.  Modifier la fonction de dessin (`drawLine`) pour dessiner les sÃ©lections locales **et** distantes.

### A. Nouvel Ã‰tat pour l'Adversaire

Ajoutez un Ã©tat pour stocker la sÃ©lection de l'adversaire dans votre composant de grille ou votre hook :

```jsx
// Dans WordGrid.jsx ou useCanvasDrawing.js
const [opponentSelection, setOpponentSelection] = useState(null); // {sender_id, start_index, end_index}
```

### B. Mettre Ã  Jour l'Ã‰tat (RÃ©ception WebSocket)

Dans votre hook WebSocket ou votre composant, lorsque vous recevez un message de type `"remote_selection"`, vous mettez Ã  jour l'Ã©tat de l'adversaire :

```javascript
// Dans la fonction socket.onmessage du Frontend

socket.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.type === "remote_selection" && data.sender_id !== playerId) {
        // Mettre Ã  jour l'Ã©tat si l'expÃ©diteur n'est pas nous-mÃªmes
        setOpponentSelection({
            sender_id: data.sender_id,
            start: data.start_index,
            end: data.end_index
        });
    }
    // ...
};
```

### C. Le Dessin sur le Canvas

Enfin, votre logique de dessin sur le Canvas doit Ãªtre adaptÃ©e pour dessiner la ligne de l'adversaire en plus de la ligne locale (si elle existe).

Le principe est que le Canvas devient l'interface pour **tous les dessins actifs**, qu'ils soient locaux ou distants. Vous aurez besoin d'une structure pour stocker plusieurs sÃ©lections actives (un tableau de sÃ©lections).